#!/usr/bin/ruby

# Author: Daniel "Trizen" È˜uteu
# License: GPLv3
# Created on: 21 August 2012
# Latest edit on: 10 November 2013
# Translated to Sidef in 21 September 2014
# Websites: http://trizen.googlecode.com

# Find the planes' positions on a grid. (text-based game)

var asciitable = (
                   try   { require 'Text::ASCIITable' }
                   catch { STDERR.print("Can't load the 'Text::ASCIITable' Perl module...\n"); Sys.exit(2) }
                 );

## Package variables
var pkgname = 'asciiplanes';
var version = 0.01;

## Game run-time constants
var BOARD_SIZE = 8;
var PLANES_NUM = 3;

var parts = (['head'] + ['hit']*7);
var plane_chars = ['$', '#', '@'];

var wrap_plane = false;
var hit_char   = %q{*};
var miss_char  = %q{`};

func usage {
    print <<"EOT";
usage: #{__FILE__} [options]

main:
        --size=i    : length side of the board (default: #{BOARD_SIZE})
        --planes=i  : the total number of planes (default: #{PLANES_NUM})
        --wrap!     : wrap the plane around the play board (default: #{wrap_plane})
        --hit=s     : character used when a plane is hit (default: "#{hit_char}")
        --miss=s    : character used when a plane is missed (default: "#{miss_char}")
        --planeN=s  : character used to draw the Nth killed plane (N=[1-99])

help:
        --help      : print this message and exit
        --version   : print the version number and exit

example:
        #{__FILE__} --size=12 --planes=6 --hit='*'

EOT

    Sys.exit;
}

func ver {
    print "#{pkgname} #{version}\n";
    Sys.exit;
}

if (ARGV.len?) {
    var getopt = (
                    try   { require 'Getopt::Long'->() }
                    catch { STDERR.print("Can't load the 'Getopt::Long' Perl module...\n"); Sys.exit(2) }
                 );

    getopt.GetOptions(
                             'board-size|size=i' => func { BOARD_SIZE = Num.new(.last)  },
                             'planes-num=i'      => func { PLANES_NUM = Num.new(.last)  },
                             'hit-char=s'        => func { hit_char   = Str.new(.last)  },
                             'miss-char=s'       => func { miss_char  = Str.new(.last)  },
                             'wrap!'             => func { wrap_plane = Bool.new(.last) },
                             'help|h|?'          => usage,
                             'version|v|V'       => ver,
                     );
}

## The play-board of the game, and some other arrays
#---------------------------------------------------------------
var play_board = 1.to(BOARD_SIZE).map { [nil] * BOARD_SIZE };
var info_board = 1.to(BOARD_SIZE).map { [' '] * BOARD_SIZE };

var letters = Hash.new;
0 ... play_board.offset -> each { |i|
    static char = 'a';
    letters[char] = i;
    char++;
}

#---------------------------------------------------------------

func pointers(board, x, y, indices) {

    var output = [];
    [[0,0]] + indices.grep{.is_an(Array)} -> each { |pair|
        var (row, col) = (x + pair[0], y + pair[1]);

        if (row > board.offset) {
            wrap_plane || return [];
            row %= board.len;
        }

        if (col > board[row].offset) {
            wrap_plane || return [];
            col %= board[row].len;
        }

        if (!wrap_plane && (row<0 || col<0)) {
            return [];
        };
        output.append(\board[row][col]);
    };

    return output;
}

func up(board, x, y) {
#<<<
    pointers(board, x, y, [
                 '[+0, +0]',
        [+1, -1], [+1, +0], [+1, +1],
                  [+2, +0],
        [+3, -1], [+3, +0], [+3, +1],
    ]);
#>>>
}

func down(board, x, y) {
#<<<
    pointers(board, x, y, [
        [-3, -1], [-3, +0], [-3, +1],
                  [-2, +0],
        [-1, -1], [-1, +0], [-1, +1],
                 '[+0, +0]',
    ]);
#>>>
}

func left(board, x, y) {
#<<<
    pointers(board, x, y, [
                    [-1, +1],           [-1, +3],
        '[+0, +0]', [+0, +1], [+0, +2], [+0, +3],
                    [+1, +1],           [+1, +3],
    ]);
#>>>
}

func right(board, x, y) {
#<<<
    pointers(board, x, y, [
        [-1, -3],           [-1, -1],
        [+0, -3], [+0, -2], [+0, -1], '[+0, +0]',
        [+1, -3],           [+1, -1],
    ]);
#>>>
}

func assign(change=false, plane=[], data=[]) {

    plane.len == 0
        && return false;

    change || (
        plane.each { |c|
            *c -> is_a(nil) || return false;
        }
    );

    0 ... plane.offset -> each { |i|
        *plane[i] = data[i];
    }

    return true;
}

func print_ascii_table {
    var table = asciitable.new(Hash.new(headingText => "#{pkgname} #{version}"));

    table.setCols(' ', 1.to(BOARD_SIZE)...);

    var char = 'a';
    info_board.each { |row|
        table.addRow([char, row...]);
        table.addRowLine();
        char++;
    }

    say table.drawit;
}

var count = 0;
var directions = [up, down, left, right];

while (count != PLANES_NUM) {
    var x = play_board.len.rand.int;
    var y = play_board[0].len.rand.int;

    var rand = directions.len.rand.int;
    var code = directions[rand];

    assign(
           change: false,
           plane:  code.call(play_board, x, y),
           data:   parts.map {|c| "#{c}_#{rand}" },
          )
    || next;

    count++;
};

## MAIN

var tries      = 0;
var start_time = Time.new.sec;

print_ascii_table();

while (count > 0) {

    var letter = letters.keys.rand;
    var number = BOARD_SIZE.inc.rand(1).int;
    var text = "=>> Your guess (e.g.: #{letter}#{number})\n> ";

    var input = Sys.scanln(text).lc;
    input ~~ ['q', 'quit'] && break;

    input =~ /^\h*([a-z]+)\D*([0-9]+)/ ?? || next;
    $1 ~~ letters                         || next;

    var x = letters[$1];
    var y = $2.to_num.dec;

    (y >= 0) && (y < BOARD_SIZE) || next;

    var point = play_board[x][y];

    if (point.is_a(nil)) {
        info_board[x][y] = miss_char;
    }
    elsif (point =~ /^head_(\d)$/i) {
        var dir  = $1.to_num;
        var item = plane_chars[(PLANES_NUM - count) % plane_chars.len];
        var code = directions[dir];

        [play_board, info_board].each { |board|
            assign(
                   change: true,
                   data:   [item]*8,
                   plane:  code.call($board, $x, $y),
                  )
              || "#{__FILE__}: unexpected error!".die;
        }

        count--;
    }
    elsif (point =~ /^hit_\d$/i) {
        info_board[x][y] = hit_char;
    }

    tries++;
    print_ascii_table();
}

printf("** Info: %d tries in %d seconds\n", tries, Time.new.sec - start_time);

if (count == 0) {
    say "** Congratulations! All the planes are destroyed!";
}
